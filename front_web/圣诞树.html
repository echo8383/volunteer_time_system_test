<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D æµªæ¼«åœ£è¯æ ‘ Â· Merry Christmas</title>
  <style>
    :root{
      --bg-top:#1a2a63; /* indigo */
      --bg-bottom:#000; /* å¤œè‰²é»‘ */
      --snow-color:#fff;
      --text-glow:#ffd6ff;
      --accent:#ffcc55; /* æ˜Ÿæ˜Ÿä¸æš–å…‰ */
      --hud-bg: rgba(255,255,255,.08);
    }
    html,body{height:100%;}
    *{box-sizing:border-box}
    body{
      margin:0; overflow:hidden; color:#f7f8ff;
      background:
        radial-gradient(160vmin 120vmin at 50% -20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, var(--bg-top), var(--bg-bottom) 70%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, "Microsoft Yahei", Helvetica, Arial;
    }
    /* æ˜Ÿç©ºå¾®ç²’ï¼ˆCSS å åŠ ï¼‰ */
    .sky{ position:fixed; inset:0; pointer-events:none; z-index:1;
      background-image:
        radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.7) 50%, transparent 55%),
        radial-gradient(1.6px 1.6px at 70% 20%, rgba(255,255,255,.55) 50%, transparent 55%),
        radial-gradient(1.2px 1.2px at 80% 60%, rgba(255,255,255,.4) 50%, transparent 55%),
        radial-gradient(1.8px 1.8px at 35% 75%, rgba(255,255,255,.5) 50%, transparent 55%);
      opacity:.35; filter: blur(.2px);
    }
    /* Three.js å®¹å™¨ */
    #app{ position:fixed; inset:0; z-index:2; }

    /* HUD æ§ä»¶ */
    .hud{ position:fixed; top:12px; right:12px; z-index:4; display:flex; gap:8px; align-items:center;}
    .hud .btn{ border:1px solid rgba(255,255,255,.2); background:var(--hud-bg); color:#dfe7ff; padding:6px 10px; border-radius:10px; cursor:pointer; backdrop-filter: blur(6px);} 
    .hud .btn:active{ transform: translateY(1px); }

    /* åœ°é¢é›¾å…‰ */
    .ground-glow{ position:fixed; left:0; right:0; bottom:-12vmin; height:42vmin; z-index:1; pointer-events:none;
      background: radial-gradient(70vmin 28vmin at 50% 20%, rgba(255,150,190,.32), rgba(255,150,190,.12) 40%, transparent 75%);
      filter: blur(12px) saturate(110%);
    }

    /* é¢„ç•™ä¸€è¡Œç¥ç¦ï¼ˆå›ºå®šåº•éƒ¨ï¼Œä¸­è‹±æ–‡éƒ½å¯ï¼‰ */
    .caption{ position:fixed; left:50%; transform:translateX(-50%); bottom:16px; width:min(92vw,1200px); z-index:5; text-align:center; }
    .caption h1{ margin:0; font-size: clamp(18px, 3.6vmin, 38px); font-weight:700; letter-spacing:.04em;
      color:#fff; text-shadow: 0 2px 6px rgba(0,0,0,.45), 0 0 10px var(--text-glow);
      animation: captionPulse 4s ease-in-out infinite;
    }
    @keyframes captionPulse{ 0%{ filter: drop-shadow(0 0 .2vmin rgba(255,255,255,.35)); } 50%{ filter: drop-shadow(0 0 1vmin rgba(255,220,255,.7)); } 100%{ filter: drop-shadow(0 0 .2vmin rgba(255,255,255,.35)); } }

    /* æ— éšœç¢ï¼šå‡å°‘åŠ¨æ•ˆ */
    @media (prefers-reduced-motion: reduce){ .caption h1{ animation:none } }
  </style>
</head>
<body>
  <div class="sky" aria-hidden="true"></div>
  <div id="app"></div>
  <div class="hud" aria-hidden="true">
    <button class="btn" id="toggleSnow">åˆ‡æ¢é›ªé‡</button>
    <button class="btn" id="toggleBloom">åˆ‡æ¢æ³›å…‰</button>
    <button class="btn" id="recenter">è§†è§’å¤ä½</button>
  </div>
  <div class="ground-glow" aria-hidden="true"></div>
  <div class="caption"><h1>âœ¨ Merry Christmas Â· æ„¿æ¸©æš–ä¸çˆ±éšé›ªèŠ±é£˜è½ ğŸ’– âœ¨</h1></div>

  <script type="module">
    // ====== ä¸‰æ–¹ä¾èµ–ï¼ˆESM CDNï¼‰ ======
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { Reflector } from 'https://unpkg.com/three@0.160.0/examples/jsm/objects/Reflector.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    // ====== åŸºç¡€åœºæ™¯ ======
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1024, 0.015);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 4.5, 12);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minPolarAngle = Math.PI * 0.2; // é™åˆ¶è§†è§’è§’åº¦æ›´åƒç«™åœ¨åœ°é¢
    controls.maxPolarAngle = Math.PI * 0.5;
    controls.target.set(0, 3.4, 0);

    // ====== ç¯å…‰ï¼ˆå†·æš–å¯¹æ¯”ï¼‰ ======
    const hemi = new THREE.HemisphereLight(0x8dd9ff, 0x0b0b0b, 0.65);
    scene.add(hemi);

    const moon = new THREE.DirectionalLight(0xb0c8ff, 0.9);
    moon.position.set(-6, 10, 8);
    moon.castShadow = true;
    moon.shadow.mapSize.set(1024,1024);
    scene.add(moon);

    const warmFill = new THREE.PointLight(0xffc15a, 1.0, 30, 2.0);
    warmFill.position.set(3, 4, 6);
    scene.add(warmFill);

    // ====== åœ°é¢åå°„ ======
    const ground = new Reflector(new THREE.CircleGeometry(14, 128), {
      textureWidth: 1024,
      textureHeight: 1024,
      color: 0x101014,
    });
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // ====== åœ£è¯æ ‘ï¼ˆå±‚å åœ†é”¥ + å°‘é‡æå¶æ‰°åŠ¨ï¼‰ ======
    const tree = new THREE.Group();
    scene.add(tree);

    const GREEN = new THREE.Color(0x1aa267);
    const MAT = new THREE.MeshStandardMaterial({
      color: GREEN,
      roughness: 0.95,
      metalness: 0.02,
    });

    const layers = 9; // å¤§å±‚æ•°
    const segmentsPerLayer = 3; // æ¯å±‚ç»†åˆ†
    const totalH = 7.2;
    for(let L=0; L<layers; L++){
      const layerTop = (totalH * (L / layers));
      const layerBottom = (totalH * ((L+1) / layers));
      const layerH = layerBottom - layerTop;
      const rTop = 0.4 + (1 - L/layers) * 0.2; // é¡¶éƒ¨å¾®å°åœ†è§’
      const baseRadius = 0.6 + (1 - L/layers) * 3.2; // è‡ªä¸Šè€Œä¸‹åŠå¾„å¢å¤§

      for(let s=0; s<segmentsPerLayer; s++){
        const k = s / segmentsPerLayer;
        const r = baseRadius * (1 - k*0.82);
        const h = layerH / segmentsPerLayer * 1.1;
        const geo = new THREE.ConeGeometry(r, h, 64, 1, true);
        // éšæœºæ‰°åŠ¨é¡¶ç‚¹ï¼Œåˆ¶é€ æ¾é’ˆä¸è§„åˆ™è¾¹ç¼˜
        const pos = geo.attributes.position;
        for(let i=0; i<pos.count; i++){
          const y = pos.getY(i);
          const f = (y/h + 0.5);
          const noise = (Math.random() - 0.5) * 0.05 * (1 - f);
          pos.setX(i, pos.getX(i) * (1 + noise));
          pos.setZ(i, pos.getZ(i) * (1 + noise));
        }
        pos.needsUpdate = true;

        const mesh = new THREE.Mesh(geo, MAT.clone());
        mesh.castShadow = true; mesh.receiveShadow = true;
        mesh.position.y = layerTop + k*layerH + 0.5;
        mesh.rotation.y = Math.random()*Math.PI*2;
        tree.add(mesh);
      }
    }

    // æ ‘å¹²
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.28, 0.36, 1.2, 16),
      new THREE.MeshStandardMaterial({ color: 0x6b4b2a, roughness:0.9 })
    );
    trunk.position.y = 0.6; trunk.castShadow = true; trunk.receiveShadow = true;
    tree.add(trunk);

    // ====== èºæ—‹å½©ç¯ï¼ˆInstancedMesh çƒä½“ + Bloomï¼‰ ======
    const BLOOM_SCENE = 1; // ä½¿ç”¨ Layer 1 å‚ä¸æ³›å…‰

    const bulbGeo = new THREE.SphereGeometry(0.07, 10, 10);
    const colors = [0xff5588, 0xffdd77, 0x66ffd0, 0x66aaff, 0xff88ff];

    const bulbCount = 650;
    const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive:0xffffff, emissiveIntensity: 2.5, roughness:0.3, metalness:0.1 });
    const bulbs = new THREE.InstancedMesh(bulbGeo, bulbMat, bulbCount);
    bulbs.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    bulbs.layers.enable(BLOOM_SCENE);
    tree.add(bulbs);

    // åœ¨åœ†é”¥ä¾§é¢ç”Ÿæˆèºæ—‹è·¯å¾„ & éšæœºç‚¹
    const tmpObj = new THREE.Object3D();
    for(let i=0; i<bulbCount; i++){
      const t = i / bulbCount; // 0~1 ä»æ ‘é¡¶åˆ°æ ‘åº•
      const height = 0.8 + t * (totalH - 0.5);
      const radius = 0.2 + (1 - t) * 3.3;
      const turns = 8.5;
      const angle = turns * Math.PI * 2 * t + Math.random()*0.2;
      const x = Math.cos(angle) * radius * (0.9 + Math.random()*0.12);
      const z = Math.sin(angle) * radius * (0.9 + Math.random()*0.12);
      tmpObj.position.set(x, height, z);
      tmpObj.updateMatrix();
      bulbs.setMatrixAt(i, tmpObj.matrix);
      // éšæœºæ¯é¢—ç¯çš„é¢œè‰²ï¼ˆé€šè¿‡é¢œè‰²å±æ€§ï¼‰
      bulbs.setColorAt(i, new THREE.Color(colors[Math.floor(Math.random()*colors.length)]));
    }

    // ====== é‡‘è‰²ä¸å¸¦ï¼ˆTubeGeometry å¼¯æ›²è·¯å¾„ï¼‰ ======
    class HelixCurve extends THREE.Curve { constructor(radius, height, turns){ super(); this.radius = radius; this.height = height; this.turns = turns; }
      getPoint(t){
        const angle = this.turns * Math.PI*2 * t;
        const r = this.radius * (1 - t*0.88);
        return new THREE.Vector3(Math.cos(angle)*r, 1 + t*(this.height-0.2), Math.sin(angle)*r);
      }
    }
    const helix = new HelixCurve(3.2, totalH, 5.5);
    const ribbonGeo = new THREE.TubeGeometry(helix, 600, 0.06, 8, false);
    const ribbonMat = new THREE.MeshStandardMaterial({ color:0xffe199, metalness:0.6, roughness:0.25, emissive:0x331900, envMapIntensity:1.2 });
    const ribbon = new THREE.Mesh(ribbonGeo, ribbonMat);
    ribbon.castShadow = true; ribbon.receiveShadow = true; ribbon.layers.enable(BLOOM_SCENE);
    tree.add(ribbon);

    // ====== æ ‘é¡¶æ˜Ÿï¼ˆIcosahedron + å¼ºå‘å…‰ï¼‰ ======
    const star = new THREE.Mesh(new THREE.IcosahedronGeometry(0.55, 0), new THREE.MeshStandardMaterial({ color:0xffd16b, emissive:0xffd16b, emissiveIntensity:6, metalness:0.3, roughness:0.2 }));
    star.position.set(0, totalH + 0.5, 0);
    star.rotateY(Math.PI/5);
    star.layers.enable(BLOOM_SCENE);
    star.castShadow = false; star.receiveShadow = false;
    tree.add(star);

    const starLight = new THREE.PointLight(0xffd16b, 2.2, 22, 2);
    starLight.position.copy(star.position);
    scene.add(starLight);

    // ====== é£˜é›ªï¼ˆPointsï¼‰ ======
    const SNOW_COUNT_BASE = 1200;
    let snowScale = 1;
    const snowGeo = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(SNOW_COUNT_BASE * 3);
    const snowSizes = new Float32Array(SNOW_COUNT_BASE);
    for(let i=0;i<SNOW_COUNT_BASE;i++){
      snowPositions[i*3] = (Math.random()-0.5)*60;
      snowPositions[i*3+1] = Math.random()*26;
      snowPositions[i*3+2] = (Math.random()-0.5)*60;
      snowSizes[i] = Math.random()*1.2 + 0.4;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
    snowGeo.setAttribute('aSize', new THREE.BufferAttribute(snowSizes, 1));

    const snowMat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{ uTime:{value:0}, uColor:{value:new THREE.Color('#ffffff')} },
      vertexShader:`
        attribute float aSize; varying float vAlpha; uniform float uTime; 
        void main(){
          vec3 pos = position;
          float t = uTime * 0.08 + position.x*0.02;
          pos.x += sin(t + position.z*0.05)*0.25; // è½»å¾®é£˜æ‘†
          pos.y = mod(position.y - uTime*0.9, 26.0); // å¾ªç¯ä¸‹è½
          vAlpha = 0.5 + fract(sin(dot(position.xy , vec2(12.9898,78.233))) * 43758.5453)*0.5;
          vec4 mvPos = modelViewMatrix * vec4(pos,1.0);
          gl_PointSize = aSize * 60.0 / -mvPos.z; // è¿œå°è¿‘å¤§
          gl_Position = projectionMatrix * mvPos;
        }
      `,
      fragmentShader:`
        precision mediump float; varying float vAlpha; uniform vec3 uColor; 
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = smoothstep(0.5, 0.0, length(uv));
          float soft = smoothstep(0.5, 0.2, length(uv));
          gl_FragColor = vec4(uColor, d * soft * vAlpha);
        }
      `
    });
    const snow = new THREE.Points(snowGeo, snowMat); scene.add(snow);

    // ====== åæœŸæ³›å…‰ ======
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.85);
    composer.addPass(bloomPass);

    // åªè®©æŸäº›å¯¹è±¡å‚ä¸ Bloomï¼šå°†å®ƒä»¬æ”¾åˆ° Layer1ï¼Œç„¶å render ä¸¤æ¬¡ï¼ˆç®€åŒ–ï¼šç›´æ¥ç”¨å…¨å±€ bloomï¼‰

    // ====== åŠ¨æ•ˆä¸å“åº” ======
    const clock = new THREE.Clock();
    let enableBloom = true;

    function animate(){
      const t = clock.getElapsedTime();

      // æ˜Ÿæ˜Ÿè½»å¾®æ—‹è½¬ã€è„‰åŠ¨
      star.rotation.y += 0.006;
      star.scale.setScalar(1 + Math.sin(t*2.2)*0.05);
      starLight.intensity = 1.8 + Math.sin(t*2.0)*0.6;

      // å½©ç¯å¾®é—ªçƒï¼ˆæ”¹å˜ emissiveIntensity ä¸è‰²æ¸©ï¼‰
      const ei = 2.1 + Math.sin(t*6.0)*0.6 + Math.sin(t*2.7 + 1.3)*0.4;
      bulbMat.emissiveIntensity = ei;

      // ä¸å¸¦è½»å¾®æ³¢åŠ¨
      ribbon.rotation.y = Math.sin(t*0.3)*0.03;

      // é£˜é›ªæ—¶é—´æ¨è¿›
      snowMat.uniforms.uTime.value = t * snowScale;

      controls.update();
      if(enableBloom){ composer.render(); } else { renderer.render(scene, camera); }
      requestAnimationFrame(animate);
    }
    animate();

    // ====== äº¤äº’ ======
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById('toggleSnow').addEventListener('click', ()=>{
      snowScale = snowScale === 1 ? 1.8 : snowScale === 1.8 ? 0.5 : 1;
    });
    document.getElementById('toggleBloom').addEventListener('click', ()=>{
      enableBloom = !enableBloom;
    });
    document.getElementById('recenter').addEventListener('click', ()=>{
      controls.target.set(0, 3.4, 0);
      camera.position.set(0, 4.5, 12);
      controls.update();
    });

  </script>
</body>
</html>
